# 최종 여행 일정 생성 및 Streamlit UI 연동

## 세션 개요
이 실습 세션에서는 여행 일정 생성 에이전트 워크플로우를 사용자 인터페이스(UI)에 연동하는 방법을 학습합니다. 지금까지는 콘솔에서 여러 에이전트(`travel_info_agent`, `local_recommendation_agent`, `coordinator_agent`)가 순차적으로 협력하여 여행 일정을 만들어냈습니다. 이번에는 **Streamlit** 웹 애플리케이션을 통해 사용자가 직접 여행 요청을 입력하고, 에이전트들이 최종 여행 일정을 생성하여 UI에 출력하도록 연결합니다. 이로써 복잡한 에이전트 로직을 사용자가 손쉽게 활용할 수 있는 **챗봇 형태의 웹 앱**으로 구현하는 방법을 배웁니다.

## Streamlit 앱 실행하기
먼저 제공된 `app.py` 파일을 실행하여 Streamlit 앱이 어떻게 동작하는지 확인해봅시다. 터미널에서 프로젝트 디렉토리로 이동한 후 다음 명령을 실행하세요:

```bash
streamlit run app.py
```

명령을 실행하면 브라우저가 열리면서 Streamlit 앱이 나타납니다. UI 상단에는 앱 제목이 표시되고(`st.title`로 설정됨), 그 아래에 **여행 계획 입력**을 위한 텍스트 상자가 보일 것입니다. 이 텍스트 영역에는 기본적으로 예시 여행 요청이 미리 입력되어 있습니다:

```
2025년 4월 25일부터 27일까지 인천을 출발해서 오사카로 여행을 다녀오려고 합니다. 항공편, 숙소, 현지 맛집, 가볼만한 곳까지 포함해서 여행 일정을 상세히 만들어주세요. 예산은 총 80만 원 이내로 잡고 있어요. 혼자 가는 여행이라 너무 비싸지 않으면서 가성비 좋은 곳들로 부탁드려요.
```

사용자는 이 내용을 참고하여 자신만의 여행 요청을 입력할 수 있습니다(또는 예시를 그대로 사용해도 됩니다). 

이제 **"여행 일정 생성하기"** 버튼을 눌러보세요. 버튼을 누르면 로딩 스피너(`st.spinner`)가 나타나며 *"일정을 생성 중입니다..."*라는 메시지가 표시됩니다. 이는 백엔드에서 에이전트들이 순차적으로 실행되어 여행 일정을 생성하고 있다는 신호입니다. 완료될 때까지 잠시 기다리면, 스피너가 사라지고 **"여행 일정 생성 완료!"**라는 성공 메시지(`st.success`)가 나타납니다. 그 아래에는 **"📝 생성된 여행 일정:"**이라는 소제목과 함께 에이전트들이 만들어낸 최종 여행 일정 결과가 화면에 표시됩니다.

이 과정에서 **사용자 입력**이 에이전트 프로세스로 전달되고 **결과가 렌더링**되는 흐름을 직접 확인할 수 있습니다. 또한 Streamlit을 실행한 터미널을 보면, 에이전트 실행 과정에서 `verbose=True` 설정 때문에 각 단계별 로그나 최종 결과 텍스트(`print(result)`에 의해 출력됨)를 확인할 수도 있습니다. 이러한 로그는 에이전트가 어떤 프롬프트를 받고 어떤 출력을 생성했는지 이해하는 데 도움을 줍니다.

## 여행 일정 생성 워크플로 (에이전트 구성)
이제 백엔드에서 **최종 여행 일정이 어떻게 생성되는지** 그 과정을 알아보겠습니다. 미리 구성된 세 명의 에이전트가 순차적인 **3단계 작업**을 통해 협업하며 일정을 만들어냅니다. `agents.py`와 `tasks.py` 파일에 이들 에이전트와 작업 내용이 정의되어 있습니다:

- **1단계 – 여행 정보 수집 (`travel_info_agent`)**: 첫 번째 에이전트는 *“여행 전문가”* 역할로서, 사용자의 요청을 바탕으로 **기본 여행 일정**을 작성합니다. 여기에는 여행 기간 동안의 **항공편 정보(왕복)**, **숙소 예약 정보**, 그리고 대략적인 **일자별 일정 초안**이 포함됩니다. 이 에이전트는 필요에 따라 항공편과 숙소 정보를 찾기 위해 도구(`FlightSearchTool`, `HotelSearchTool`, `ExchangeRateTool`)를 활용합니다. 예를 들어, 인천→오사카 왕복 항공편 가격이나 오사카의 숙소 가격을 조회하여 예산에 맞는 옵션을 찾을 수 있습니다. 이러한 정보를 종합하여 **“일자별 기본 여행 일정과 비용 초안”**을 텍스트로 출력합니다.

- **2단계 – 현지 추천 추가 (`local_recommendation_agent`)**: 두 번째 에이전트는 *“현지 전문가”* 역할로서, 1단계에서 만들어진 기본 일정에 **현지 맛집**, **명소 추천**, 그리고 상세한 **예산 내역**을 추가합니다. 이 단계에서는 **NearbyPlacesTool**과 **ExchangeRateTool** 등의 도구를 활용하여, 예를 들어 *오사카 현지인들에게 인기 있는 맛집이나 숨은 명소*를 검색하고 일자별 일정에 끼워 넣습니다. 또한 항목별 비용(식사 비용, 입장료 등)을 원화 기준으로 계산하고, 총 예산 내에서 계획이 이루어지도록 세부 **예산표**를 작성합니다. 이 에이전트는 1단계의 출력을 **컨텍스트로 입력받아** 작업하며, 결과물로 **“현지 맛집과 명소가 포함된 업데이트된 일정 + 상세 예산표”**를 만들어냅니다.

- **3단계 – 일정 최종 조정 (`coordinator_agent`)**: 마지막으로 *“여행 일정 코디네이터”* 역할의 에이전트가 앞선 두 단계의 결과를 종합하여 **최종 여행 일정 계획서**를 완성합니다. 이 에이전트는 2단계 결과를 기반으로 내용을 다듬고 부족한 부분을 채워, **사용자에게 제공할 완성된 형태의 일정**을 작성합니다. 여기에는 **일자별 세부 일정**, **항공편 및 숙소 상세 정보**, **총 비용 및 예산 요약**, 그리고 추가로 유용한 **현지 정보** 등이 깔끔하게 정리됩니다. 말하자면, 코디네이터 에이전트는 앞서 수집된 모든 정보를 한데 모아 **일관성 있고 보기 쉬운 최종 아웃풋**으로 만들어 주는 역할을 합니다.

위 과정은 `crew.py`의 `TravelCoordinatorCrew` 클래스를 통해 정의된 **Crew**에 의해 관리됩니다. Crew는 `agents=[travel_info_agent, local_recommendation_agent, coordinator_agent]`와 `tasks=[initial_travel_plan_task, local_recommendation_task, final_coordinator_task]`를 묶어 **순차적(Process.sequential)으로 실행**하도록 설정되어 있습니다. 각 Task에는 해당 단계에서 에이전트가 수행할 업무(프롬프트)가 정의되어 있고, 필요한 경우 이전 단계의 결과를 `context`로 참조하도록 구성되어 있습니다. 예를 들어, 2단계 `local_recommendation_task`는 `context=[initial_travel_plan_task]`로 지정되어 1단계 결과를 전달받으며, 3단계 `final_coordinator_task`는 `context=[local_recommendation_task]`로 2단계 결과를 입력받습니다. 이런 구조 덕분에 **coordinator_agent는 travel_info_agent와 local_recommendation_agent의 출력물을 모두 활용**하여 최종 일정을 조율할 수 있게 됩니다.

요약하면, **사용자 입력 → 1단계 에이전트 출력 → 2단계 에이전트 출력 → 3단계 에이전트 최종 출력** 순서로 작업이 흐르며, 최종 산출물이 우리에게 필요한 완성된 여행 일정입니다.

## Streamlit 앱 코드 분석 (`app.py`)
이제 Streamlit 앱 코드(`app.py`)의 주요 부분을 살펴보면서, 앞서 설명한 에이전트 워크플로우가 어떻게 UI와 연결되는지 이해해보겠습니다.

### 1. 사용자 입력 처리 (텍스트 영역)
우선 Streamlit 앱이 시작되면 타이틀과 함께 사용자 입력을 받을 수 있는 텍스트 영역이 설정됩니다. 관련 코드는 다음과 같습니다:

```python
st.title("🚀 여행 일정 계획 챗봇")

user_input = st.text_area(
    "여행 계획을 입력해 주세요:",
    "2025년 4월 25일부터 27일까지 인천을 출발해서 오사카로 여행을 다녀오려고 합니다. "
    "항공편, 숙소, 현지 맛집, 가볼만한 곳까지 포함해서 여행 일정을 상세히 만들어주세요. "
    "예산은 총 80만 원 이내로 잡고 있어요. "
    "혼자 가는 여행이라 너무 비싸지 않으면서 가성비 좋은 곳들로 부탁드려요."
)
```

- `st.title("...")` : 웹 앱의 맨 위에 표시되는 제목을 설정합니다. 이 예제에서는 로켓 이모지와 함께 "여행 일정 계획 챗봇"이라는 제목이 나타납니다.
- `st.text_area("여행 계획을 입력해 주세요:", default_text)` : 여러 줄의 텍스트를 입력받을 수 있는 **텍스트 영역**을 생성합니다. 첫 번째 인자는 필드 레이블(프롬프트 문구)이고, 두 번째 인자로 기본 값(default)을 설정하고 있습니다. 여기서는 미리 완성된 여행 요청 예시 문장을 기본값으로 제공하여, 사용자가 입력 형식을 이해하기 쉽도록 했습니다. 이 텍스트 영역에 입력된 값이 `user_input` 변수에 문자열로 저장됩니다.

**동작:** 사용자가 텍스트 상자에 여행 요청 내용을 입력하거나 기본 예시를 수정한 후, 아래의 버튼을 누르면 `user_input` 문자열이 후속 에이전트 로직에 전달됩니다.

### 2. Crew 실행 및 일정 생성 (버튼 클릭 처리)
사용자 입력을 완료했다면, 이제 **"여행 일정 생성하기"** 버튼으로 에이전트들을 실행합니다. `app.py`에서는 버튼과 연계된 코드 블록이 다음과 같이 구현되어 있습니다:

```python
if st.button("여행 일정 생성하기"):
    with st.spinner("일정을 생성 중입니다..."):
        inputs = {'content': user_input}
        result = TravelCoordinatorCrew().crew().kickoff(inputs=inputs)
    st.success("여행 일정 생성 완료!")
    ...
```

- `st.button("여행 일정 생성하기")` : 버튼을 생성하고, 사용자가 클릭하면 내부 블록이 실행됩니다. 이 함수는 Boolean 값을 반환하므로, `if st.button(...):` 형태로 클릭 여부를 체크합니다.
- `with st.spinner("일정을 생성 중입니다..."):` : 버튼 클릭 시 긴 작업가 진행되는 동안 사용자에게 피드백을 주기 위한 **스피너**를 표시합니다. 이 컨텍스트 내부의 코드가 실행되는 동안 "일정을 생성 중입니다..."라는 로딩 메시지와 함께 회전 로딩 아이콘이 나타납니다.
- `inputs = {'content': user_input}` : 에이전트에게 전달할 입력을 딕셔너리 형태로 준비합니다. `Crew.kickoff`에서는 이 딕셔너리를 받아 Task의 `{content}` 자리 등에 채워 넣습니다. 여기서 키 `'content'`는 `tasks.py`에서 각 Task 프롬프트에 사용되는 플레이스홀더와 일치해야 합니다. (Task 정의에서 "요청: {content}"처럼 사용됨)
- `result = TravelCoordinatorCrew().crew().kickoff(inputs=inputs)` : **Crew 인스턴스**를 생성하고 `kickoff` 메소드를 호출하여 에이전트 프로세스를 실행합니다. `TravelCoordinatorCrew().crew()`는 미리 정의된 3개 에이전트와 3개 Task를 포함한 Crew 객체를 반환합니다. `kickoff`를 호출하면 다음 순서로 작업이 수행됩니다:
  1. `travel_info_agent`가 `initial_travel_plan_task`를 실행 (사용자 `content`가 프롬프트에 삽입되어 실행됨).
  2. `local_recommendation_agent`가 `local_recommendation_task`를 실행 (이때 1단계의 출력이 컨텍스트로 제공됨).
  3. `coordinator_agent`가 `final_coordinator_task`를 실행 (2단계 출력이 컨텍스트로 제공됨).
  
  각 단계별로 에이전트는 OpenAI API(예: GPT) 호출을 통해 응답을 생성하며, 필요한 경우 자신의 도구를 사용해 API 호출(항공편 검색, 장소 검색 등)을 수행합니다. 모든 단계가 완료되면 **최종 결과**를 `result` 변수에 문자열 형태로 반환합니다. 이 한 줄의 코드로 복잡한 에이전트 협업 로직이 캡슐화되어 실행되는 것입니다.
- `st.success("여행 일정 생성 완료!")` : 작업 완료 후 사용자에게 성공 메시지를 보여줍니다. 초록색 체크 아이콘과 함께 메시지를 출력하여, 일정 생성이 끝났음을 명확히 알립니다.

### 3. 일정 결과 출력 (Markdown 렌더링)
이제 `result`에 담긴 최종 여행 일정 계획서를 사용자에게 보여줄 차례입니다. `app.py`에서는 결과를 표시하기 위해 다음과 같은 코드를 사용했습니다:

```python
    # 생성된 일정 결과 출력
    st.markdown("### 📝 생성된 여행 일정:")
    st.markdown(result)
    print(result)
```

- `st.markdown("### 📝 생성된 여행 일정:")` : Markdown 문법을 사용하여 결과 섹션의 제목을 출력합니다. `"###"`은 3단계 헤더(markdown H3 크기)에 해당하므로, 화면에는 비교적 작은 제목으로 "📝 생성된 여행 일정:"이 표시됩니다.
- `st.markdown(result)` : 에이전트들이 생성한 최종 여행 일정 문자열을 그대로 마크다운으로 렌더링하여 화면에 표시합니다. 에이전트의 출력은 한국어로 작성된 여러 줄의 텍스트일 텐데, `st.markdown`을 사용함으로써 만약 결과 문자열에 Markdown 형식(예: `- 목록`이나 `### 소제목`, 테이블 등)이 포함되어 있다면 적절하게 포매팅되어 보여집니다. 예를 들어, 일정 결과가 일자별로 리스트 형식으로 작성되었다면 해당 부분이 불릿 포인트 목록으로 렌더링될 것입니다.
- `print(result)` : 터미널(console)에 최종 결과 문자열을 출력합니다. 이 부분은 웹 앱 UI에는 영향을 주지 않지만, 개발자가 터미널에서 원시 출력 내용을 확인하거나 디버깅하는 데 유용합니다.

**지금까지의 정리:** 현재 코드는 **텍스트 형태**의 최종 일정을 화면에 표시합니다. 사용자는 한꺼번에 완성된 여행 일정 문서를 확인할 수 있죠. 기본적으로 Markdown을 활용하여 가독성을 높였지만, UI/UX를 더욱 향상시키기 위해 결과를 **표나 카드 형태**로 부분적으로 표현할 수도 있습니다. 다음 단계에서는 이런 개선 사항들을 직접 적용해보겠습니다.

### 4. 프롬프트 포맷 구조 (Task 구성 방식)
마지막으로, 에이전트에게 전달되는 **프롬프트**가 어떻게 구성되는지 살펴보겠습니다. 이는 `tasks.py`에 정의된 Task들의 `description`과 `context` 속성을 통해 이뤄집니다. 각 Task는 해당 단계에서 에이전트가 수행해야 할 지시사항(프롬프트 내용)을 갖고 있으며, 여기에 이전 단계 결과나 사용자 입력이 삽입됩니다. 구조는 다음과 같습니다:

- **사용자 입력 삽입:** 1단계 `initial_travel_plan_task`에서는 `description`에 *"{content}"* 플레이스홀더가 포함되어 있습니다. `kickoff` 호출시 우리가 전달한 `inputs={'content': user_input}`에 의해, `{content}`가 사용자의 실제 요청 내용으로 대체됩니다. 예컨대 `initial_travel_plan_task`의 프롬프트는 다음과 같이 정의되어 있습니다:

  ```python
  initial_travel_plan_task = Task(
      description=(
          "다음 고객의 요청을 바탕으로 항공편(왕복), 숙소를 포함한 여행 일정을 작성합니다. "
          "요청: {content}"
      ),
      expected_output="한국어로 작성된 일자별 기본 여행 일정과 비용 초안 (항공편(왕복), 숙소 포함)",
      agent=travel_info_agent,
  )
  ```
  
  여기서 `"요청: {content}"` 부분이 사용자의 입력 문자열로 치환되어 에이전트에게 주어집니다. 즉, 여행 정보 에이전트는 **사용자 요청 문장 전체를 포함**한 지시를 받게 되는 것이죠.

- **이전 단계 결과 활용:** 2단계와 3단계는 각각 `context` 필드를 통해 이전 Task의 결과를 참조합니다. 예를 들어 `local_recommendation_task`는 `context=[initial_travel_plan_task]`로 설정되어 1단계 결과를 입력으로 받습니다. Crew가 이 Task를 실행할 때는 1단계의 출력물을 2단계 에이전트에게 전달합니다. 구체적으로 2단계 `description`을 보면 “**1단계에서 작성된 일자별 기본 여행 일정과 비용을 검토한 후, ... 현지 맛집과 명소를 추천**...” 이라고 되어 있습니다. 에이전트는 이 지시를 수행하기 위해 1단계 일정이 무엇인지 알아야 하므로, crew가 해당 내용을 내부적으로 프롬프트에 포함하거나 대화 맥락에 추가해주는 것입니다. 마찬가지로 `final_coordinator_task`는 `context=[local_recommendation_task]`로 2단계 출력을 넘겨받아, 3단계 프롬프트에서 활용합니다. 이렇게 함으로써 마지막 코디네이터 에이전트는 1단계와 2단계의 모든 정보를 종합적으로 인지한 상태에서 최종 아웃풋을 생성할 수 있습니다.

- **프롬프트 예시와 기대 출력:** 각 Task에는 `expected_output` 필드도 정의되어 있는데, 이는 에이전트가 **어떤 형식과 내용을 산출해야 하는지에 대한 가이드**입니다. 예를 들어 2단계 `expected_output`에는 “현지 맛집과 명소가 포함된 업데이트된 일자별 여행 일정과 상세 예산표”라고 명시되어 있어, 에이전트가 결과에 반드시 **명소 추천 및 예산표**를 포함하도록 유도합니다. 이러한 기대 출력 설명은 프롬프트의 일부는 아니지만 (내부 구현에 따라 시스템 메시지로 활용될 수도 있고, 단순 참고용일 수도 있습니다), 우리에게 최종 결과물이 어떻게 생길지 예상하게 해줍니다. 

정리하면, **Task의 description 템플릿**과 **context 메커니즘**이 결합되어 다단계 프롬프트 체인이 만들어집니다. 이를 통해 각 에이전트는 자기 역할에 충실한 답변을 생성하고, 최종적으로 일관성 있는 하나의 여행 일정이 완성됩니다. 이러한 프롬프트 포맷 구조를 잘 설계하면 사람이 일일이 긴 프롬프트를 작성하지 않아도 되며, 체계적으로 LLM(대형 언어 모델)의 힘을 빌려 복잡한 요구사항을 단계별로 해결할 수 있습니다.

## 실습 과제: UI 개선
이제 기본 동작을 확인했으니, Streamlit 앱의 UI와 출력 형식을 좀 더 개선해보겠습니다. 아래에 제시된 과제를 하나씩 수행하면서 코드 수정 및 앱 동작 변화를 경험해보세요. **코드를 수정한 후에는 앱을 새로고침하거나 다시 실행**해야 변경 사항이 반영됩니다.

### 과제 1: 두 컬럼 레이아웃으로 UI 변경
현재 앱 UI는 한 열로 구성되어 있어, 입력 상자와 결과가 세로로 나열됩니다. 이를 **두 개의 컬럼**으로 나누어, 좌측에는 입력 영역을, 우측에는 결과 출력 영역을 배치해 봅시다. 이렇게 하면 화면 공간을 보다 효율적으로 활용하고, 입력과 출력을 한눈에 비교하기 쉽습니다.

**실습 가이드:**
1. `st.columns` 함수를 사용하여 두 개의 컬럼 객체를 생성합니다. 예시: `col1, col2 = st.columns(2)`
2. 첫 번째 컬럼(`col1`)에 **입력 위젯**들을 배치합니다. `with col1:` 블록 내에 `st.text_area`와 `st.button` 코드를 넣으면 됩니다. 이렇게 하면 텍스트 상자와 버튼이 좌측 컬럼에 정렬됩니다.
3. 두 번째 컬럼(`col2`)에 **출력 부분**을 배치합니다. 버튼 클릭 후 결과를 표시하는 `st.markdown` 등을 `with col2:` 블록 내에서 실행하도록 변경하세요. 즉, 결과 제목("생성된 여행 일정:")과 결과 `st.markdown(result)` 출력이 우측 컬럼에 나타나게 됩니다.

**힌트:** Streamlit의 컬럼은 동일한 너비로 분할되며, 각 컬럼 객체 (`col1`, `col2` 등)의 메소드를 사용하거나 `with` 구문을 통해 해당 컬럼 영역에 컴포넌트를 배치합니다. 예를 들어:

```python
col1, col2 = st.columns(2)

with col1:
    user_input = st.text_area("여행 계획을 입력해 주세요:")
    generate = st.button("여행 일정 생성하기")

with col2:
    if generate:  # 버튼이 눌렸다면
        with st.spinner("일정을 생성 중입니다..."):
            result = TravelCoordinatorCrew().crew().kickoff(inputs={'content': user_input})
        st.success("여행 일정 생성 완료!")
        st.markdown("### 📝 생성된 여행 일정:")
        st.markdown(result)
```

위 코드는 하나의 구현 예시입니다. 핵심은 **입력과 출력**이 분리된 컬럼에서 이루어지도록 하고, 상태 변화(버튼 클릭 등)를 적절히 처리하는 것입니다. 코드를 수정한 후 앱을 다시 실행/새로고침하여, 입력란이 좌측에, 생성된 일정 결과가 우측에 표시되는지 확인해 보세요.

### 과제 2: 일정 결과를 표(**Table**) 형식으로 표시
현재 최종 여행 일정은 대부분 문단과 리스트로 이루어진 **텍스트 형식**입니다. 내용을 보다 구조적으로 표현하기 위해 일부 데이터를 **표(table)**로 출력해보는 연습을 해봅시다. 예를 들어 **예산 내역**이나 **일자별 일정 요약**을 표로 나타내면 가독성이 향상될 수 있습니다.

**실습 가이드:**
1. `st.markdown(result)`으로 한꺼번에 출력하는 대신, `result` 문자열을 분석하여 표로 나타낼 수 있는 부분을 찾아보세요. 예컨대, 결과 문자열에 비용이나 예산과 관련된 줄이 있다면 해당 부분을 추출할 수 있습니다. (만약 에이전트가 이미 마크다운 표 형식으로 예산을 작성했다면, `st.markdown`만으로 표가 그려졌을 수도 있습니다. 그렇지 않은 경우 직접 파싱해보는 연습을 합니다.)
2. 파이썬 문자열 메소드를 활용하여 `result`에서 특정 패턴을 찾습니다. 예를 들어 각 **예산 항목**이 `"항목: 금액"` 형태로 되어 있다면, `result.splitlines()`로 줄 단위 리스트를 만든 뒤 `":"` 구분자를 기준으로 항목과 금액을 분리할 수 있습니다.
3. 표 데이터를 준비합니다. Streamlit의 `st.table()`이나 `st.dataframe()`은 파이썬의 **리스트**나 **딕셔너리, 판다스 DataFrame** 등을 받아 테이블을 출력할 수 있습니다. 간단히, 예산 항목들을 딕셔너리의 리스트로 만들어볼 수 있습니다. 예:
   ```python
   budget_data = []
   for line in result.splitlines():
       if ":" in line and "원" in line:
           item, cost = line.split(":", 1)
           budget_data.append({"항목": item.strip(), "비용": cost.strip()})
   if budget_data:
       st.table(budget_data)
   ```
   위 코드는 결과 문자열에서 `:`가 포함되고 `원` (통화) 단위가 언급된 줄을 찾아 "`항목`"과 "`비용`" 컬럼이 있는 표 데이터를 구성한 예시입니다. 실제 결과 포맷에 맞게 로직을 조정해야 합니다.
4. 표로 출력한 나머지 부분(예를 들어 **일정 세부 내용**)은 그대로 `st.markdown`이나 `st.write`로 출력하면 됩니다. 원하는 경우 표와 텍스트를 섞어서 출력할 수도 있습니다.

**주의:** 에이전트 출력의 형식은 완벽히 정형화되어 있지 않을 수 있으므로, 파싱 로직은 상황에 따라 다르게 동작할 수 있습니다. 이번 과제에서는 결과 내용을 유연하게 다뤄보는 경험에 중점을 두세요. 표로 만들 데이터가 없다면, 직접 임의의 간단한 표 데이터를 만들어 `st.table()`로 출력해 보는 것도 좋습니다. 중요한 것은 Streamlit에서 **표 형식 컴포넌트**를 사용하는 방법을 익히는 것입니다.

### 과제 3: 입력 예시 프롬프트 고정 표시
현재 텍스트 입력 상자에는 예시 요청이 기본값으로 들어가 있지만, 사용자가 내용을 지우면 예시를 다시 볼 수 없습니다. 혹은 기본 예시가 너무 길어 텍스트 상자가 처음부터 꽉 차 보이는 단점도 있습니다. 이를 개선하기 위해 **예시 요청 내용을 텍스트 상자 아래에 별도로 고정 표시**해보겠습니다. 이렇게 하면 입력란은 비워두거나 간략히 안내하고, 그 아래에 항상 예시 형식을 보여줄 수 있습니다.

**실습 가이드:**
1. `st.text_area`의 기본 값을 빈 문자열 `""` 또는 짧은 안내 문구로 변경합니다. 예를 들어:
   ```python
   user_input = st.text_area("여행 계획을 입력해 주세요:", "")
   ```
   이렇게 하면 텍스트 상자가 비어있고, placeholder처럼 사용할 수 있습니다. (Streamlit 최신 버전에서는 `placeholder` 매개변수를 사용할 수도 있습니다. 예: `st.text_area("여행 계획 입력:", "", placeholder="여행 요청 내용을 입력하세요.")`)
2. 텍스트 입력 상자 바로 아래에 예시 내용을 보여주기 위한 컴포넌트를 추가합니다. 간단하게 `st.markdown`을 활용해 예시를 텍스트로 표시하거나, `st.info`를 사용해 배경이 있는 박스로 나타낼 수 있습니다. 예:
   ```python
   st.markdown('<p style="font-size:0.9em; color:gray;">예시: 2025년 4월 25일부터 27일까지 인천...</p>', unsafe_allow_html=True)
   ```
   또는
   ```python
   st.info("**예시 입력:** 2025년 4월 25일부터 27일까지 인천을 출발해서 ... 가성비 좋은 곳들로 부탁드려요.")
   ```
   위와 같이 하면 텍스트 상자 아래에 회색 박스나 정보 블럭으로 예시를 고정적으로 보여줄 수 있습니다. **굵은 글씨**나 작은 폰트 등을 사용해 시각적으로 입력창과 구분되도록 하면 좋습니다.
3. 예시를 표시할 때 너무 장황하지 않게, 핵심 요소(여행 날짜, 출발/도착지, 요구 사항, 예산 등)를 포함한 한 두 문장으로 요약해도 됩니다. 중요한 것은 사용자가 **어떤 형식으로 요청을 작성하면 되는지** 참고할 수 있게 하는 것입니다.

이 변경을 적용한 후 앱을 새로 열어 보면, 텍스트 상자는 비어있고 바로 아래에 회색 글씨로 예시 요청이 따로 보이게 될 것입니다. 사용자는 예시를 참고하여 입력하거나, 복사하여 편집할 수도 있습니다.

## 추가 도전 과제: 여행지 추천을 카드(Card) 형식으로 출력
위의 과제를 모두 마쳤다면, 추가로 도전해볼 만한 과제를 소개합니다. 2단계 현지 추천 에이전트는 여행지의 맛집이나 명소를 여러 곳 추천해줄 것입니다. 현재는 이 정보가 텍스트 본문에 나열되어 있지만, 이를 **카드 형태의 UI**로 꾸며 보면 어떨까요? 카드 형식이란 각각의 추천 장소를 개별 박스나 섹션으로 구분하고, 내용과 스타일을 갖춰 보여주는 방식을 말합니다. 예를 들어, 장소 이름을 헤더로, 주소나 한줄 설명을 본문으로, (가능하다면 이미지나 아이콘을 첨부하여) 시각적으로 구분된 여러 개의 박스로 보여줄 수 있습니다.

**도전 가이드:**
- **출력 데이터 분리:** 먼저 최종 결과 문자열에서 추천 장소들만 따로 추출하는 방법을 생각해봅니다. 만약 명소/맛집 리스트가 불릿 포인트(`-`)로 나열되어 있다면 이를 이용할 수 있고, 아니면 일정에서 장소 이름 패턴을 찾아 분리할 수도 있습니다. 또는 애초에 2단계 에이전트가 `NearbyPlacesTool`을 통해 얻은 상세 정보를 사용하려면 코드 구조를 바꿔야겠지만, 여기서는 간단히 현재 **문자열 결과를 파싱**하는 접근으로 설명하겠습니다.
- **카드 레이아웃:** Streamlit에는 카드 전용 컴포넌트는 없지만, 몇 가지 방법으로 유사한 효과를 낼 수 있습니다. 
  - **방법 1:** `st.container()`와 `st.columns()`를 활용해 다단 레이아웃으로 배치하기. 예를 들어 2개 열을 만들어 한 행에 두 개의 추천지를 나란히 표시하면 카드가 격자 형태로 배치됩니다. 각 카드 내부에서는 `st.markdown`이나 `st.write`로 내용(이름, 설명 등)을 출력합니다.
  - **방법 2:** `st.expander`를 이용해 추천 장소별로 접을 수 있는 패널을 만드는 것 또한 한 방법입니다. `st.expander("장소 이름")`을 사용하면 제목이 있는 카드를 만들고, 클릭하면 상세 내용이 펼쳐지도록 할 수 있습니다. 기본 상태에서는 장소 이름들만 보이므로 깔끔하고, 클릭 시 세부정보(주소, 평점, 리뷰 등)를 표시할 수 있습니다.
  - **방법 3:** HTML/CSS를 사용한 커스텀 카드 디자인. `st.markdown`에 `unsafe_allow_html=True` 옵션을 주고 `<div>` 태그 등을 사용해 스타일을 직접 넣을 수 있지만, 스트림릿 기본 기능 밖이므로 복잡합니다. 간단한 스타일 정도(예: 테두리, 배경색)라면 시도해 볼 수 있습니다.
- **내용 구성:** 카드에는 **장소 이름**, **간략 설명**(예: 카테고리나 대표 메뉴), **추가 정보**(평점이나 예상 비용 등)을 포함할 수 있습니다. 2단계에서 이미 이런 정보들을 텍스트로 주었다면 그대로 활용하면 되고, 보다 구조화하려면 해당 텍스트를 나눠 담으면 됩니다. 
- **이미지 추가 (선택):** 가능하다면 추천 장소와 관련된 이미지를 찾아 `st.image`로 카드에 넣어보세요. 예를 들어, 각 장소 이름을 구글 검색해서 나온 이미지를 수동으로 링크하거나, OpenAI나 Kakao API 등을 이용해 이미지를 가져오는 방법도 있습니다. 이미지가 없다면 아이콘(🍣🍜 음식, 🗼명소 등 이모지)으로 대체해도 좋습니다.

**예시:** (아이디어)  
만약 "오사카 맛집 - 텐동XX (새우튀김 덮밥, 4.5/5)" 이런 식의 한 줄 추천이 있다면, 이를 카드로 만들 때:  
- 카드 제목: **텐동XX**  
- 카드 본문: *"새우튀김 덮밥이 유명한 현지 맛집입니다. 평점 4.5/5"* 등으로 작성.  
- 여러 카드를 만들고 두 열 배치.

이 추가 과제를 수행하면, 사용자는 일정보고서 하단에서 추천 장소들을 마치 여행 가이드북의 추천 섹션처럼 개별 카드로 볼 수 있을 것입니다. 이는 사용자 경험을 풍부하게 하고, 정보를 빠르게 파악하는 데 도움을 줍니다.

---

이상으로 **"최종 여행 일정 생성 및 Streamlit UI 연동"** 실습을 마칩니다. 이번 세션에서는 에이전트 기반의 여행 일정 생성 로직을 웹 애플리케이션과 결합하여, 실제 사용자에게 서비스를 제공할 수 있는 형태로 발전시켜 보았습니다. UI 구성 요소를 다루고 출력을 다채롭게 표현하면서, 백엔드 로직과 프론트엔드 표시를 연결하는 방법을 이해하셨길 바랍니다. 앞으로 여러분이 직접 다양한 프로젝트에서 AI 에이전트를 활용한 멋진 인터페이스를 구현해보길 기대합니다!

