# 항공편 및 숙소 API 연동 실습 가이드

## 실습 목표
이 실습의 목표는 **항공편 검색 API**와 **숙소 검색 API**를 파이썬 CLI 환경에서 연동하여, 사용자의 여행 요청에 맞는 **여행 일정을 자동 생성**하는 과정을 이해하는 것입니다. 참가자는 `FlightSearchTool`과 `HotelSearchTool` 등의 도구를 활용해 실제 항공편 운임과 숙박 정보를 조회하고, 이를 **여행 일정 플래너 에이전트**가 통합하여 일자별 일정과 예산을 작성하는 흐름을 실습하게 됩니다. 또한 각 단계별 **프롬프트 설계** 방법을 살펴보고, 더 나은 응답을 얻기 위한 **프롬프트 개선** 기법을 연습합니다.

## 사전 준비
- **필요 파일 및 라이브러리**: 제공된 코드 베이스(`main.py`, `tools.py`, `agents.py`, `tasks.py`, `crew.py` 등)와 `CrewAI` 라이브러리가 설치되어 있어야 합니다. (`CrewAI`는 다중 에이전트 시스템을 구축하기 위한 프레임워크로, Crew, Agent, Task 등의 개념을 사용합니다.)
- **API 키 설정**: 실제 항공편/숙소 정보를 조회하기 위해 Amadeus API와 Google Places API의 키가 필요합니다. 프로젝트 디렉터리에 `.env` 파일을 생성하여 `AMADEUS_CLIENT_ID`, `AMADEUS_CLIENT_SECRET`, `GOOGLE_API_KEY`, `EXCHANGE_RATE_API_KEY` 등을 설정하세요. `tools.py`에서 이들을 불러와 사용합니다.
- **실행 환경**: Python 3 환경에서 터미널을 사용해 실습을 진행합니다. (이 실습에서는 Streamlit 웹 UI를 사용하지 않고, CLI로 `main.py`를 실행합니다.)

## 실습 단계별 안내

이 실습은 **세 단계의 에이전트 작업**으로 구성됩니다. 각 단계마다 전담 에이전트가 정해진 **Task(작업)**를 수행하며, 앞 단계의 결과를 다음 단계에서 활용합니다. 이제 단계별로 상세 내용을 살펴보겠습니다.

### 1단계: 기본 여행 일정 수립 (항공편 & 숙소 포함)
**여행 전문가 에이전트(`travel_info_agent`)**가 사용자 요청을 바탕으로 **왕복 항공편**과 **숙소 정보**를 조회하고, 이를 포함한 기본 여행 일정을 작성하는 단계입니다. 이 단계에서는 `FlightSearchTool`과 `HotelSearchTool`을 활용하여 실제 데이터를 가져오며, 그 결과를 토대로 **일자별 여행 일정 초안**을 만듭니다. 

- **사용자 요청 입력**: `main.py`에 하드코딩된 예시 입력을 살펴보면, 내용은 다음과 같습니다:

  *“2025년 4월 25일부터 27일까지 인천을 출발해서 오사카로 여행을 다녀오려고 합니다. 항공편, 숙소, 현지 맛집, 가볼만한 곳까지 포함해서 여행 일정을 상세히 만들어주세요. 예산은 총 80만 원 이내로 잡고 있어요. 혼자 가는 여행이라 너무 비싸지 않으면서 가성비 좋은 곳들로 부탁드려요.”*

  여기서 사용자 요청에는 여행 기간, 출발/도착지, 요구 사항(항공편, 숙소, 맛집, 명소), 예산 등이 명시되어 있습니다.

- **에이전트 및 도구 구성**: `travel_info_agent`는 역할이 "여행 전문가"로 설정되어 있고, **항공편과 숙소 정보를 수집**하는 것이 목표입니다. 이 에이전트에는 `FlightSearchTool`, `HotelSearchTool`, `ExchangeRateTool` 세 가지 도구가 장착되어 있습니다. 이번 단계에서는 주로 항공편과 숙소 도구를 사용하게 됩니다.

- **FlightSearchTool 활용**: 항공편 검색 도구는 Amadeus API를 통해 주어진 출발지/도착지와 날짜에 대한 항공편 정보를 최대 10건 받아옵니다. `FlightSearchTool`은 도시명을 IATA 공항 코드로 변환한 뒤 API를 호출하며, 결과로 **항공편 목록**(리스트)을 반환합니다. 각 항공편 정보는 `가격`, `통화`, `출발지`, `목적지`, `출발일`, `항공사 코드`, `편명`, `출발시간`, `도착시간` 등을 포함합니다. 

  예를 들어, 인천→오사카 (2025-04-25 출발, 1명)으로 검색하면 다음과 같은 Python 리스트 결과를 얻을 수 있습니다 (실제 값은 변경될 수 있습니다):

  ```python
  from tools import FlightSearchTool
  flights = FlightSearchTool().run(origin_city="인천", destination_city="오사카", departure_date="2025-04-25", adults=1)
  print(flights)
  # 예상 출력 (항공편 목록 예시):
  # [ 
  #   {
  #     "가격": "300000", "통화": "KRW",
  #     "출발지": "ICN", "목적지": "OSA", "출발일": "2025-04-25",
  #     "항공사": "OZ", "편명": "112",
  #     "출발시간": "2025-04-25T09:00:00", "도착시간": "2025-04-25T11:00:00"
  #   },
  #   { ... 두 번째 항공편 ... },
  #   ...
  # ]
  ```

  위 예시에서 첫 번째 항공 옵션은 **대한항공(OZ) 112편**이 4월25일 09:00에 ICN을 출발하여 11:00에 OSA 도착하며, 가격은 300000 KRW(30만원)인 것을 볼 수 있습니다. 실제로 `FlightSearchTool` 코드를 보면 이러한 구조의 리스트를 생성하고 반환하는 것을 확인할 수 있습니다.

- **HotelSearchTool 활용**: 숙소 검색 도구는 Amadeus API를 통해 특정 도시와 체크인/체크아웃 날짜에 이용 가능한 호텔 리스트를 검색합니다. `HotelSearchTool`은 먼저 도시명을 Amadeus 도시 코드로 변환한 후, 해당 도시의 호텔 ID 목록을 가져오고 각 호텔별 **가격 제안(offers)** 정보를 조회합니다. 그 결과로 **가능한 호텔 목록**(리스트)을 반환하며, 각 항목에는 `hotel_name` (호텔 이름), `check_in`, `check_out`, `room_description` (방 유형/설명), `total_price` (총 가격), `currency` (통화) 필드가 포함됩니다.

  예를 들어, 오사카 (2025-04-25 체크인, 2025-04-27 체크아웃, 1명)으로 검색하면 다음과 같은 결과 목록을 얻을 수 있습니다 (예시):

  ```python
  from tools import HotelSearchTool
  hotels = HotelSearchTool().run(city_name="오사카", check_in_date="2025-04-25", check_out_date="2025-04-27", adults=1)
  print(hotels)
  # 예상 출력 (호텔 목록 예시):
  # [
  #   {
  #     "hotel_name": "오사카 시티 호텔",
  #     "check_in": "2025-04-25",
  #     "check_out": "2025-04-27",
  #     "room_description": "스탠다드 트윈룸 (금연)",
  #     "total_price": "50000", "currency": "JPY"
  #   },
  #   { ... 두 번째 호텔 ... },
  #   ...
  # ]
  ```

  위 예시에서는 **오사카 시티 호텔**의 트윈룸 2박이 50,000 JPY(엔)임을 보여줍니다. 실제 코드에서도 각 호텔의 이름과 가격 정보를 이와 같은 딕셔너리로 담아 리스트를 반환하고 있습니다.

- **기본 일정 작성**: `travel_info_agent`는 위 두 도구의 검색 결과를 활용하여 **여행 일정 초안**을 작성합니다. 에이전트는 **LLM**(대형 언어 모델)을 기반으로 동작하며, 주어진 **Task 설명**을 프롬프트로 받아 행동합니다. 1단계의 Task(`initial_travel_plan_task`) 설명을 보면 *“다음 고객의 요청을 바탕으로 항공편(왕복), 숙소를 포함한 여행 일정을 작성”*하도록 명시되어 있습니다. 이 지시에 따라 에이전트는 먼저 항공편과 숙소 정보를 얻기 위해 도구들을 호출하고, 그 결과를 토대로 일정 텍스트를 구성합니다. 

  **👉 예상 동작**: 에이전트는 검색된 항공편 목록 중 적절한 항공편(예: 가격이 저렴하고 시간대가 맞는 항공편)을 선택하고, 호텔 목록 중 이용 가능한 괜찮은 숙소를 선택합니다. 그런 다음, 예를 들어 **Day 1** 일정을 작성할 때 선택한 왕복 항공편의 **출발 시간/도착 시간, 항공사 이름, 편명, 가격** 정보를 언급하고, 도착 후 **숙소 체크인** 계획을 포함시킵니다. **Day 3** 일정에는 귀국 편 정보를 포함시키겠죠. 

  예를 들어 1단계 결과 일정의 일부가 다음과 같이 작성될 수 있습니다:

  - *Day 1 (4월 25일)*: 오전 9시에 인천공항을 출발하는 **OZ112편 항공기**를 이용하여 오사카 간사이공항 도착 (도착시간 11:00). 항공권 가격은 약 **300,000원**입니다. 오사카 도착 후 예약한 **오사카 시티 호텔**에 체크인합니다 (2박 총 **¥50,000** ≈ 50만원). <small>*(여기서 항공편 정보와 호텔 정보를 실제 검색 결과에 기반하여 서술)*</small>

  - *Day 2 (4월 26일)*: 오사카에서 종일 자유 여행 (세부 일정은 다음 단계에서 추가 예정).

  - *Day 3 (4월 27일)*: 오후에 호텔 체크아웃 후 **대한항공 OZ113편**으로 오사카에서 인천으로 귀국 (출발 18:00 → 도착 20:30). 왕복 항공편 비용은 총 **300,000원** 정도이며, 여행 후 남은 시간에 공항 면세점을 둘러볼 수 있습니다.

  위는 예상 예시이지만, 실제 에이전트가 생성하는 텍스트도 이와 비슷하게 **항공편 정보**(시간, 항공사, 가격)와 **숙소 정보**(이름, 숙박비용)를 포함하여 일정을 기술하게 됩니다. 1단계의 결과물은 이후 단계의 입력으로 활용되며, 파일 구조상 `initial_travel_plan_task`의 출력이 2단계에서 `context`로 참조됩니다.

  이제 준비가 되었으면, **`main.py`를 실행하여 1단계 작업을 포함한 전체 일정을 생성**해보세요. 터미널에서 아래 명령을 실행합니다:

  ```bash
  $ python main.py
  ```

  `main.py`에서는 미리 정의된 `TravelCoordinatorCrew`를 실행하여 세 단계 작업을 순차적으로 수행합니다. 각 에이전트와 Task의 상세 동작은 `verbose=True` 설정으로 인해 터미널 로그에 출력됩니다. 따라서 실행 후 터미널에 표시되는 로그를 주의 깊게 관찰하면:
  - **여행 전문가 에이전트**가 도구를 호출하고 항공편/숙소 정보를 찾은 뒤, **1단계 일정 초안**을 출력하는 과정을 볼 수 있습니다. (`FlightSearchTool`과 `HotelSearchTool` 사용 내역 및 선택된 정보 등이 로그에 나타날 것입니다.)
  - 이어서 2단계, 3단계 에이전트들의 동작과 최종 출력이 순서대로 나타납니다.

### 2단계: 현지 추천 정보 및 예산 추가
**현지 전문가 에이전트(`local_recommendation_agent`)**가 1단계의 일정 초안을 바탕으로, **현지 맛집과 명소 추천** 및 **예산 상세 정리**를 수행하는 단계입니다. 이 단계에서는 주로 `NearbyPlacesTool`과 `ExchangeRateTool` 도구를 활용합니다. 

- **현지 맛집/명소 추가**: `NearbyPlacesTool`은 Google Places API를 통해 특정 지점을 중심으로 반경 내 인기 장소(관광지, 음식점 등)를 검색합니다. 2단계 Task는 1단계 일정에서 비어있는 부분(예: Day 2의 세부 일정)에 현지인들이 즐겨 찾는 **식당**, **카페**, **관광 명소** 등을 채우고자 합니다. 에이전트는 1단계 결과(예: 여행지: 오사카, 숙소 위치 등)를 참고하여 적절한 키워드로 `NearbyPlacesTool`을 호출할 것입니다. 예를 들어 *"오사카 맛집 추천"* 혹은 *"오사카 관광 명소"* 등을 검색하여 상위 5곳 정도의 정보를 얻고, 이를 일정에 반영합니다. 

  현지 전문가 에이전트는 각 날짜별로 **아침/점심/저녁에 갈 음식점 이름과 인기 메뉴**, **방문할 만한 관광지 이름** 등을 추가하며, 괄호 등을 사용해 **예상 비용**도 함께 표기합니다. 예를 들어 Day 2 일정이 다음과 같이 상세해집니다:

  - *Day 2 (4월 26일)*: 오전에 **도톤보리 거리** 산책 및 구경. 점심으로 현지 인기 라멘 맛집 **이치란 라멘** 방문 (예상 비용 ¥1,000). 오후에는 **오사카 성** 관광 (입장료 ¥600). 저녁에는 **쿠로몬 시장**에서 해산물 먹거리 투어 (예상 ¥2,000). 하루 교통비 ¥800 포함.

- **예산 상세 및 환율 반영**: 이 단계에서는 여행 경비를 상세히 계산하고 예산 내에 드는지 검토합니다. 항목별 (항공, 숙소, 식비, 교통, 입장료 등) 예상 비용을 합산하고, 사용된 통화가 다를 경우 `ExchangeRateTool`을 이용해 환율 계산도 수행합니다. 예를 들어 숙소 비용 ¥50,000은 원화로 얼마인지 변환하거나, 전체 예산 80만원 대비 현재 합계 비용이 어느 정도인지 등을 계산합니다. `ExchangeRateTool`은 환율 API를 통해 실시간 환율을 가져와 금액 변환 결과를 제공하므로, 이를 참고하여 원화 환산 값을 일정이나 예산표에 추가하게 됩니다.

  2단계 작업의 결과물로 **현지 맛집/명소가 포함되고, 환율 고려된 상세 예산표가 추가된 일정**이 완성됩니다. 이 결과 역시 다음 최종 단계의 입력으로 전달됩니다.

  참고로, `main.py` 실행 시 2단계 과정도 터미널 로그에 나타납니다. 현지 전문가 에이전트가 `NearbyPlacesTool`을 통해 찾은 추천 장소들과 `ExchangeRateTool`을 통한 환율 변환 내용, 그리고 업데이트된 일정을 출력하는 과정을 확인하세요. 

### 3단계: 전체 일정 최종 정리
**코디네이터 에이전트(`coordinator_agent`)**가 앞서 완성된 일정을 최종 검수하고 보기 좋게 정리하는 단계입니다. 이 에이전트는 추가적인 도구 없이, 이전 단계들에서 생성된 여행 일정 내용을 **종합적으로 통합 및 서식화**하는 역할을 합니다. 

- **최종 편집 및 서식**: 코디네이터 에이전트는 최종 사용자에게 전달할 보고서 형태로 일정을 다듬습니다. 예를 들어 일자별 제목을 달고, 항공편/숙소/맛집/명소/예산 정보를 **체계적으로 정렬**합니다. 필요한 경우 앞 단계 결과에서 중복되거나 어색한 표현을 다듬고, 전체 흐름이 매끄러운지 확인합니다. Task 정의에 따르면 *“최종적인 여행 일정을 깔끔하게 정리”*하고 *“일자별 일정표, 상세 예산표”* 등을 명확하고 보기 쉽게 만든다고 되어 있습니다. 따라서 최종 출력은 마치 여행사가 제공하는 **여행 일정표 문서**처럼 정리되어 있을 것입니다.

- **예상 최종 결과물**: 최종 출력은 한국어로 작성된 **여행 일정 계획서**이며, 여객에게 바로 제공할 수 있는 형태입니다. 구조는 다음과 같은 요소를 포함할 수 있습니다:
  - **여행 개요**: 여행 기간, 목적지, 총 예상 비용 등 개요 정보.
  - **일자별 일정**: Day 1, Day 2, Day 3 ... 형태로 날짜별 세부 일정 (항공편 정보, 식사/관광 계획, 숙소 정보 포함).
  - **상세 예산표**: 항목별 비용 (항공권, 숙박, 식비, 교통, 입장료 등)을 환율 반영하여 원화 기준으로 정리, 총합과 예산 대비 여부 명시.
  - **추가 정보**: 준비물 또는 참고사항 등 (필요에 따라).

  예를 들면, 일정표 일부가 다음과 같이 구성될 것입니다:

  ```
  ## 1일차 (4월 25일 금요일): 인천 → 오사카
  - 오전 9:00 인천 출발 ✈️ (대한항공 OZ112편, 11:00 오사카 도착) — **항공요금:** 300,000원  
  - 오사카 도착 후 호텔 체크인 🏨 (오사카 시티 호텔, 2박 **¥50,000** ≈ 500,000원)  
  - 저녁: 도톤보리 관광 및 이치란 라멘에서 저녁 식사 🍜 (¥1,000)

  ## 2일차 (4월 26일 토요일): 오사카 현지 탐방
  - 오사카 성 등 관광 명소 투어 🏯 (입장료 ¥600)  
  - 쿠로몬 시장에서 해산물 시식 🦐 (¥2,000) …  
  - ...(생략)...

  ## 3일차 (4월 27일 일요일): 오사카 → 인천 귀국
  - 호텔 체크아웃 후 간사이 공항 이동 🚕 (교통비 ¥2,000)  
  - 오후 6:00 오사카 출발 ✈️ (대한항공 OZ113편, 8:30pm 인천 도착) — **항공요금:** (왕복 포함) 300,000원  
  - 밤 10:00 인천 도착. 여행 종료.

  **총 예상 경비:** 740,000원 (환율 적용, 약 ¥74,000) – 예산 800,000원 이내  
  ```

  *<small>위는 형식 예시이며, 실제 출력은 에이전트에 의해 동적으로 생성됩니다.</small>*

  `main.py` 실행을 완료하면 터미널에 최종 일정 결과가 출력됩니다. 해당 결과를 확인하여 항공편/숙소 정보가 제대로 포함되었는지, 예산 내역이 명확히 정리되었는지 검토해 보세요. 코디네이터 에이전트의 역할 덕분에 최종 문서가 한눈에 보기 좋게 구성된 것을 볼 수 있습니다.

## 주요 개념 정리
- **Crew (크루)와 Sequential Task 처리**: `TravelCoordinatorCrew`는 사전에 정의된 여러 에이전트를 **순차적(Sequential)**으로 실행하여 복잡한 작업을 달성합니다. 각 단계(Task)의 출력이 다음 단계의 입력(Context)으로 전달되어, 단계별 결과를 누적하며 최종 응답을 만들어냅니다. 이 구조를 통해 작업을 단계별로 분담하고 협업하는 효과를 얻습니다.
- **에이전트와 도구(툴) 활용**: 각 에이전트는 자신에게 할당된 도구를 사용하여 **실시간 정보**를 가져옵니다. 예를 들어 여행 전문가는 `FlightSearchTool`과 `HotelSearchTool`로 항공권과 숙소 데이터를 검색하고, 현지 전문가는 `NearbyPlacesTool`로 맛집/명소를 찾고 `ExchangeRateTool`로 환율을 계산했습니다. 이러한 **외부 API 연동 도구**를 통해 최신 정보를 얻고, 답변에 반영할 수 있습니다.
- **프롬프트와 Task 설명**: 에이전트가 따르는 지침은 Task에 정의된 **description(설명)**과 사용자 입력 내용입니다. 명확한 프롬프트 설계를 통해 에이전트가 무엇을 해야 하는지 정확히 이해시킬 수 있습니다. 예를 들어 "항공편(왕복), 숙소를 포함한 일정"이라고 지정함으로써 에이전트는 반드시 항공편과 숙소 정보를 포함해야 함을 인지합니다. 프롬프트가 모호하면 에이전트의 응답 품질이 떨어질 수 있으므로, **Task 설명을 요구사항에 맞게 구체적으로 작성**하는 것이 중요합니다.
- **단계별 결과 통합**: 여러 단계의 출력물을 하나의 최종 응답으로 **조합**할 때, 일관성과 완결성을 유지해야 합니다. 이번 실습에서는 1단계 일정 → 2단계 추가정보 → 3단계 최종정리를 거치면서, 각 단계의 내용이 유기적으로 합쳐졌습니다. 항공편/숙소 정보 같은 경우 1단계에서 제공된 것을 3단계까지 유지하면서, 2단계에서 추가된 식당/명소 정보 및 예산 정보와 함께 최종 문서에 균형 있게 포함되었습니다.
- **검증과 개선**: 생성된 일정이 요구사항에 부합하는지 검토하고, 부족한 부분은 **프롬프트 수정**이나 **추가 단계**를 통해 개선할 수 있습니다. 예를 들어 항공편 정보에 누락된 세부사항이 있다면 해당 내용을 더 명시적으로 요청하거나, 예산이 초과된다면 예산 준수를 강조하는 프롬프트로 수정하는 식입니다. 다음 섹션에서는 이러한 **프롬프트 개선**의 예시를 살펴봅니다.

## 프롬프트 개선 실습 예제
프롬프트 설계에 따라 에이전트의 출력이 어떻게 달라지는지 확인하기 위해, 몇 가지 상황별 **프롬프트 개선 방법**을 예제로 알아보겠습니다.

- **예시 1: 세부 정보 누락 시 프롬프트 보강**  
  가령 1단계 결과에서 항공편은 포함되었지만 **항공사 이름이나 출발/도착 시간이 언급되지 않았다**고 합시다. 이는 프롬프트에 해당 세부 정보를 명시하도록 요구하지 않았기 때문일 수 있습니다. 원래 프롬프트에서는 단순히 “항공편(왕복)”만 요구했지만, 이를 개선하여 **어떤 세부 정보를 포함해야 하는지 구체화**할 수 있습니다.  
  **개선 전**: *"항공편(왕복), 숙소를 포함한 여행 일정"*  
  **개선 후**: *"항공편(왕복)의 **항공사, 출발/도착 시간, 가격 정보**와 숙소의 **이름, 위치, 숙박비**를 포함한 여행 일정"*  

  이렇게 프롬프트를 보강하면, 에이전트는 항공편 세부 사항(예: 대한항공 OZ112, 09:00 출발/11:00 도착, 30만원)과 숙소 세부 사항(호텔 이름과 위치, 가격)을 빠뜨리지 않고 언급하게 될 것입니다. 프롬프트의 작은 변화로도 응답 내용의 **디테일 수준**을 조절할 수 있음을 확인해보세요.

- **예시 2: 응답 활용 방식 개선 – 예산 고려**  
  사용자 예산이 충분하지 않은데 에이전트가 너무 비싼 항공편이나 호텔을 선택하는 경우를 생각해봅니다. 이런 경우 1단계 프롬프트나 사용자 요청에 **예산 준수 조건**을 강조하는 문장을 추가하면 도움이 됩니다.  
  **개선 전**: 사용자 요청에 예산 언급은 있지만 1단계 Task 설명에는 예산 고려 지시가 없음.  
  **개선 후**: 1단계 Task 설명에 *"예산 범위 내에서 최적의 항공편과 숙소 선택"* 이라는 문구 추가.  

  이를 통해 에이전트는 도구로 데이터를 검색한 후 **여러 옵션 중 예산에 맞는 선택**을 하도록 유도됩니다. 예를 들어, 항공편 검색 결과 중 가장 저렴한 옵션을 선택하거나, 호텔도 가성비 좋은 곳으로 고르게 될 것입니다. 이렇게 하면 최종 일정이 초기 예산을 초과하지 않고 사용자 요구에 더 부합하게 됩니다.

- **예시 3: 출력 형식 개선**  
  에이전트 출력이 가독성 있게 나오도록 유도하는 것도 프롬프트 개선의 한 부분입니다. 만약 3단계 최종 일정이 장황하게 한 문단으로 나온다면, 프롬프트에 **목록이나 표 형태로 정리**하도록 지시해볼 수 있습니다. 예를 들어 "*일자별로 목록을 만들어 일정과 비용을 정리하세요.*"와 같은 지시를 추가하면, 항목별로 줄바꿈된 목록 형태 출력이 이루어질 가능성이 높습니다. 이렇듯 **출력 형식(format)**도 프롬프트로 제어할 수 있습니다.

위 사례들을 직접 시험해 보려면, 해당 Task의 `description` 문구를 수정한 후 `main.py`를 다시 실행해보세요. 작은 프롬프트 변화가 일정 결과물에 어떤 변화를 가져오는지 비교해보는 것이 큰 도움이 됩니다.

## 마무리 및 도전 과제
이번 실습에서는 **여행 일정 생성 AI 에이전트**를 구성하여, 실제 항공편 및 숙소 API를 연동하고 여러 단계의 프롬프트를 통해 복합적인 응답을 만들어내는 과정을 연습했습니다. 초기 여행 정보 수집부터 현지 추천 추가, 최종 취합까지 단계별로 문제를 나누어 해결함으로써, 복잡한 요구사항도 효과적으로 처리할 수 있음을 배웠습니다. 또한 **프롬프트 엔지니어링**을 통해 원하는 정보를 정확하고 풍부하게 얻어내는 방법도 살펴보았습니다.

이제 아래의 도전 과제를 통해 이해도를 높이고 응용력을 키워보세요:

- **도전 과제 1: 새로운 여행 시나리오 적용**  
  다른 여행 시나리오로 입력을 바꿔서 `main.py`를 실행해 보세요. 예를 들어, *"내년 봄에 3박4일 일정으로 부산에서 도쿄 여행 계획"*과 같은 요청으로 바꾸면 일정이 어떻게 생성되는지 확인합니다. 여행지나 기간이 달라지면 항공편/숙소 검색 결과와 추천 내용도 변화할 것입니다. 다양한 입력을 시험하며 에이전트의 대응 능력을 살펴보세요.

- **도전 과제 2: 에이전트 및 도구 확장**  
  제공된 구조를 응용하여 **새로운 기능**을 추가해보세요. 예를 들어, 여행지의 **날씨 정보**를 제공하는 Weather API를 연동하는 `WeatherTool`을 만들어 현지 전문가 에이전트에 추가하고, 일정에 날씨 예보를 포함하도록 해볼 수 있습니다. 또는 **여행자 맞춤 추천**(예: 아이 동반 여행, 액티비티 위주 등)을 위한 에이전트를 하나 더 Crew에 추가하여 4단계 구성을 시도해도 좋습니다. 이런 확장은 실제 서비스 개발에서 AI 에이전트를 활용하는 폭을 넓혀줄 것입니다.

- **도전 과제 3: 최적화 및 고급 기능**  
  더 나은 일정을 위해 **항공편과 숙소 선택 알고리즘**을 개선해보세요. 현재는 에이전트가 검색 결과를 단순 활용하지만, 만약 가장 가격이 저렴한 조합을 찾거나 평점이 높은 호텔을 우선 선택하도록 로직을 추가하면 결과 품질이 향상될 수 있습니다. 필요하다면 에이전트 대신 Python 코드 상에서 필터링을 수행한 뒤 에이전트에게 전달하는 방식도 고려해볼 수 있습니다. 또한, CrewAI의 **hierarchical process** 등을 조사하여, 매니저 에이전트가 서브 에이전트를 조정하는 형태로 개편해 보는 것도 고급 도전 과제입니다.

실습을 완료한 여러분은 이제 **LLM 에이전트와 외부 데이터 연동**에 대한 기본적인 이해를 갖추게 되었습니다. 이를 바탕으로 더욱 풍부한 AI 서비스를 개발하거나, 다른 분야의 API와 결합하여 창의적인 프로젝트를 수행해보세요. 즐거운 여행 일정 플래닝이 되었길 바랍니다! 


