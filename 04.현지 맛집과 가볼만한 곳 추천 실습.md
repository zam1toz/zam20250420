# 현지 맛집과 가볼만한 곳 추천 실습

이 실습은 **CrewAI 기반 여행 플래너 코스**의 4번째 세션인 **"현지 맛집과 가볼만한 곳 추천 실습"**에 대한 가이드입니다. 이번 실습에서는 이전 세션에서 다진 CrewAI의 기본 개념을 바탕으로, 여행 플래너 앱에 현지 정보 추천 기능을 추가하고 개선합니다. 특히 **에이전트(Agent)**, **태스크(Task)**, **크루(Crew)** 간의 동작 흐름을 이해하고, `local_recommendation_agent`의 프롬프트를 개선하며, Streamlit과 같은 UI 없이 **터미널에서 애플리케이션을 실행**해 보겠습니다. 또한 실제 API 호출을 통해 **현지 맛집 및 관광지 추천 정보**를 받아오도록 구현하여, 보다 현실감 있는 여행 일정을 작성해볼 것입니다.

## 에이전트, 태스크, 크루 간의 흐름 이해하기

CrewAI에서는 **에이전트**(Agent), **태스크**(Task), 그리고 그것들을 묶어 관리하는 **크루**(Crew)가 핵심 구성 요소입니다. 이번 섹션에서는 코드 상에서 이들이 어떻게 정의되고 서로 연결되는지 살펴보겠습니다. 이를 통해 각 단계별로 어떤 일이 이루어지는지 이해하고, 필요에 따라 흐름을 수정하는 방법도 알아봅니다.

크루는 여러 에이전트와 태스크를 포함하며, **여행 일정 생성 프로세스**를 단계별로 구성합니다. 우리의 `TravelCoordinatorCrew`는 세 가지 에이전트와 세 가지 태스크를 순차적으로 실행하도록 설정되어 있습니다. 각 태스크는 담당 에이전트와 **설명(description)**, **기대 출력(expected_output)**, 그리고 **이전 단계 컨텍스트(context)**를 정의합니다. 아래 `TravelCoordinatorCrew`의 코드에서 크루 생성 부분을 확인해봅시다:

```python
# crew.py - TravelCoordinatorCrew 클래스
return Crew(
    agents=[travel_info_agent, local_recommendation_agent, coordinator_agent],
    tasks=[initial_travel_plan_task, local_recommendation_task, final_coordinator_task],
    process=Process.sequential,
    verbose=True
)
```

위 코드에서 `agents` 리스트에 세 에이전트가 등록되고, `tasks` 리스트에 세 단계의 태스크가 정의됩니다. `process=Process.sequential` 덕분에 태스크들은 순서대로 (1단계→2단계→3단계) 실행됩니다. `verbose=True`로 설정되어 있어 실행 중 상세 로그를 확인할 수 있습니다. 이제 각 단계별 태스크와 에이전트의 역할을 알아보겠습니다.

### 1단계: 기본 여행 정보 작성 (travel_info_agent)

**첫 번째 태스크**는 사용자의 여행 요청에 따라 **기본 여행 일정과 큰 비용 윤곽**을 작성하는 단계입니다. 이 태스크는 `travel_info_agent` 에이전트가 담당합니다. 항공편(왕복)과 숙소 정보를 중심으로 일자별 거친 일정을 생성하게 됩니다. 해당 태스크의 정의는 `tasks.py`에서 다음과 같이 볼 수 있습니다:

```python
# 1단계: 기본 여행 정보 작성 (travel_info_agent)
initial_travel_plan_task = Task(
    description=
        "다음 고객의 요청을 바탕으로 항공편(왕복), 숙소를 포함한 여행 일정을 작성합니다. "
        "요청: {content}",
    expected_output="한국어로 작성된 일자별 기본 여행 일정과 비용 초안 (항공편(왕복), 숙소 포함)",
    agent=travel_info_agent,
)
```

- `description`: 에이전트에게 주어진 작업 설명입니다. **{content}** 부분에는 사용자가 입력한 요청 내용이 삽입됩니다. 즉, 이 태스크는 사용자의 여행 요구사항(출발지, 목적지, 날짜, 예산 등)을 기반으로 일정을 세우도록 안내하고 있습니다.
- `expected_output`: 기대되는 출력물의 형태를 서술합니다. 여기서는 *"한국어로 작성된 일자별 기본 여행 일정과 비용 초안..."*으로, 에이전트가 한글로 일정과 대략적인 비용을 작성할 것을 기대합니다.
- `agent`: 이 태스크를 수행할 에이전트로 **travel_info_agent**가 지정되어 있습니다.

**travel_info_agent**는 "여행 전문가" 역할을 하며, 항공편, 호텔 등의 정보를 찾기 위한 도구들을 보유하고 있습니다. `agents.py`를 보면 travel_info_agent는 `FlightSearchTool`, `HotelSearchTool`, `ExchangeRateTool` 등을 사용할 수 있도록 설정되어 있습니다. 따라서 **1단계**에서 에이전트는 필요한 경우 항공편 검색 API나 호텔 검색 API를 호출하여 실제 데이터를 얻고, 이를 토대로 사용자 요구에 맞는 기본 일정을 구성하게 됩니다. (예: 인천->오사카 왕복 항공편 정보 조회, 오사카 숙박 정보 조회 등)

이 단계의 결과로 **항공편 일정**, **숙소 예약 정보**, 그리고 **여행 기간 동안의 일자별 대략적 일정과 예상 비용**이 포함된 초안이 생성됩니다. 이 결과는 다음 단계의 입력으로 활용됩니다.

### 2단계: 현지 맛집 및 명소 추천 (local_recommendation_agent)

**두 번째 태스크**는 1단계에서 만들어진 기본 일정에 **현지 맛집 추천, 숨은 명소 안내, 그리고 세부 예산 추가**를 하는 단계입니다. 이 태스크는 `local_recommendation_agent` 에이전트가 담당합니다. 해당 태스크 정의를 살펴보겠습니다 (`tasks.py` 파일):

```python
# 2단계: 현지 추천 정보 및 예산 추가 (local_recommendation_agent)
local_recommendation_task = Task(
    description=(
        "1단계에서 작성된 일자별 기본 여행 일정과 비용을 검토한 후, "
        "여행 일정에서 아침/점심/저녁 식사와 간식으로 즐길 수 있는 "
        "현지에서 인기있는 맛집과 메뉴를 추가하고(가격 포함), 가볼만한 명소를 추천합니다.(비용 포함) "
        "또한, 환율을 고려한 여행 경비 예산을 상세히 작성합니다. "
        "항목별 예산이 명확히 정리되어야 합니다."
    ),
    expected_output="한국어로 작성된 상세 예산표와 현지 맛집과 명소가 포함된 업데이트된 일자별 여행 일정",
    agent=local_recommendation_agent,
    context=[initial_travel_plan_task]  # 1단계 결과 참조
)
```

- `description`: 이 단계에서 해야 할 일을 구체적으로 지시합니다. 핵심 내용은 **"기본 일정과 비용을 검토하고, 각 날의 아침/점심/저녁/간식에 현지 맛집(메뉴와 가격 포함)을 추가하며, 가볼만한 명소 추천 (비용 포함), 그리고 환율을 고려한 상세 예산표 작성"**입니다. 한 마디로, **여행 일정에 현지 추천 정보를 풍부하게 덧붙이고 전체 예산을 계산**하는 역할입니다.
- `expected_output`: 업데이트된 일정에는 현지 맛집/명소와 상세 예산이 포함되어 있어야 함을 강조합니다.
- `agent`: **local_recommendation_agent**가 이 태스크를 수행합니다.
- `context`: `[initial_travel_plan_task]`가 지정되어 있습니다. 이것이 중요합니다. **context**는 이 태스크에 이전 단계 결과를 전달하는 역할을 합니다. 즉, 1단계에서 생성된 여행 일정 초안을 두 번째 단계 에이전트가 참고할 수 있게 됩니다. CrewAI 프레임워크는 이 컨텍스트를 자동으로 `local_recommendation_agent`에게 제공하여, 이전 출력물을 기반으로 작업하도록 도와줍니다.

**local_recommendation_agent**는 "현지 전문가" 역할로 설정되어 있습니다. 이 에이전트는 `NearbyPlacesTool`과 `ExchangeRateTool`이라는 도구를 갖고 있는데, 이를 통해 **현지 맛집/명소 정보 검색**과 **환율 변환**을 할 수 있습니다. (해당 도구들에 대해서는 이후 API 연동 부분에서 자세히 다룹니다.) 

2단계에서는 이 에이전트가 1단계 일정에 **맛집 추천**을 끼워 넣고 **현지 관광지**를 제안합니다. 예를 들어:
- 아침에는 현지인에게 인기있는 **맛집 A**에서 로컬 음식 **X**를 맛보고 (가격 **¥Y**, 한화 환산 **Z원**),
- 점심에는 **맛집 B**에서 ...,
- 저녁에는 **맛집 C**...
- 오후에 **관광지 D** 방문 (입장료 **¥E** 등),
- 이 모든 비용을 환율 계산하여 **예산표**에 정리.

이러한 내용을 생성하기 위해 에이전트는 자신의 **도메인 지식**(사전 지식)과 **도구를 통한 실제 데이터**를 조합해 활용합니다. `NearbyPlacesTool`을 사용하면 특정 위치 주변의 맛집이나 관광명소 정보를 얻을 수 있고, `ExchangeRateTool`은 외화 금액을 원화로 변환하는데 쓰입니다. 에이전트는 **1단계 결과(항공편, 호텔, 기본일정)**를 입력으로 받아, 거기에 추가 정보를 삽입하고 예산을 보완하게 됩니다.

### 3단계: 일정 최종 정리 (coordinator_agent)

**세 번째 태스크**는 최종적으로 모든 정보를 취합하여 **완성된 여행 일정**을 깔끔하게 정리하는 단계입니다. 이 부분은 `coordinator_agent` 에이전트가 담당합니다. 태스크 정의는 다음과 같습니다 (`tasks.py` 파일):

```python
# 3단계: 전체 일정 최종 정리 (coordinator_agent)
final_coordinator_task = Task(
    description=(
        "앞선 모든 단계의 결과를 종합하여 최종적인 여행 일정을 깔끔하게 정리하고, "
        "고객에게 제시할 수 있도록 일자별 여행 일정과 예산을 명확하고 보기 쉽게 만듭니다."
    ),
    expected_output="한국어로 작성된 고객에게 전달할 최종 여행 일정 계획서(항공편 상세, 숙소 상세, 전체 비용, 일자별 일정표, 상세 예산표, 추가 정보)",
    agent=coordinator_agent,
    context=[local_recommendation_task]  # 2단계 결과 참조
)
```

- `description`: 이전 모든 결과를 **종합**하여, 사용자가 보기 좋게 **최종 여행 일정표**를 만들어내라는 지시입니다. 각 날의 일정과 비용이 한 눈에 들어오도록 깔끔하게 정리하라는 점을 강조하고 있습니다.
- `expected_output`: 최종 산출물에는 **항공편 상세, 숙소 상세, 전체 비용, 일자별 일정표, 상세 예산표, 추가 정보** 등이 포함된 문서여야 함을 명시합니다. 즉, 지금까지 나온 모든 정보를 하나의 완결된 계획서로 만드는 것입니다.
- `agent`: **coordinator_agent**가 수행합니다.
- `context`: `[local_recommendation_task]`가 지정되어 있어, 2단계의 출력(현지 추천이 반영된 일정)을 받아 처리합니다.

**coordinator_agent**는 "여행 일정 코디네이터" 역할로, 앞선 두 에이전트의 작업을 합치고 다듬는 **총괄자**입니다. 이 에이전트는 특별한 도구 없이도 (tools가 없습니다) 전체 일정을 조정하고 형식을 정리하는 데 초점을 둡니다. 예를 들어, 1단계와 2단계의 내용이 조금 중복되거나 흐트러져 있다면 이를 자연스럽게 다듬고, 최종 문서를 완성된 형태로 만들어주는 역할입니다.

세 단계의 실행이 모두 끝나면, `final_coordinator_task`의 출력이 **최종 결과물**로 얻어집니다. CrewAI의 `Crew.kickoff()` 메서드는 이러한 일련의 태스크를 정의된 순서대로 실행하면서 각 태스크 결과를 다음 태스크에 넘겨주고, 마지막 태스크의 출력을 반환합니다.

이처럼 **에이전트-태스크-크루** 구조를 이해하면, 필요시 흐름을 변경하거나 추가 요구사항에 맞춰 조정할 수도 있습니다. 예를 들어 다른 에이전트를 삽입하거나 태스크 순서를 바꾸는 것도 가능하지만, 일반적으로는 의존 관계(`context`)를 유지하면서 순서를 정하게 됩니다. 이번 시나리오에서는 이미 자연스러운 순서로 정의되어 있으므로 그대로 진행하겠습니다.

## `local_recommendation_agent` 에이전트 프롬프트 개선하기

이제 2단계를 담당하는 **local_recommendation_agent**의 프롬프트를 개선해보겠습니다. 여기서 말하는 "프롬프트"란 에이전트의 행동을 결정하는 사전 설정(예: 역할, 목표, 배경지식 등)을 의미합니다. 에이전트의 응답 품질을 높이기 위해, 특히 **현지 정보 추천**에 있어 더 정확하고 풍부한 답변을 할 수 있도록 에이전트의 설정을 수정해보겠습니다.

먼저 `agents.py`에서 local_recommendation_agent의 현재 정의를 확인합니다:

```python
local_recommendation_agent = Agent(
    role="현지 전문가",
    goal="여행 목적지에서 현지인이 선호하는 장소와 특별한 경험을 추천하여 여행을 풍성하게 합니다.",
    backstory="당신은 현지 문화와 지역 정보를 잘 이해하며, 현지 맛집, "
              "숨은 명소 등을 추천하는 전문가입니다. "
              "여행자가 현지에서 더욱 특별하고 기억에 남는 경험을 할 수 있도록 도와줍니다.",
    tools=[
        NearbyPlacesTool(),
        ExchangeRateTool()
    ],
    verbose=True
)
```

이 에이전트의 **역할(role)**은 "현지 전문가"이고, **목표(goal)**는 "여행자를 위해 현지인이 사랑하는 장소와 특별한 경험을 추천"하는 것입니다. **배경 설정(backstory)**에는 이 에이전트가 현지 문화와 숨은 명소까지 잘 알고 있으며 여행자에게 특별한 경험을 제공해준다는 내용이 담겨 있습니다. 또한 위에서 확인했듯 도구로 `NearbyPlacesTool`과 `ExchangeRateTool`을 사용할 수 있게 되어 있습니다.

현재 설정도 충분히 좋지만, 출력 결과를 더욱 개선하기 위해 몇 가지를 고려해볼 수 있습니다:

- **실제 데이터 활용 언급**: 에이전트가 가용한 도구를 활용하여 **정확한 최신 정보를 가져오도록** 유도하면, 허구의 정보를 줄이고 실제 존재하는 맛집/명소를 추천할 가능성이 높아집니다.
- **예산 및 환율 강조**: 이 에이전트는 예산까지 계산해야 하기 때문에, **환율 및 비용 감각**을 강조하는 배경을 추가하면 보다 현실적인 예산 설계를 기대할 수 있습니다.
- **프롬프트 어조**: 친절하면서도 **구체적인 지침**을 추가하면, 에이전트가 더 명확한 기준으로 응답하게 됩니다.

이러한 점을 개선하기 위해 `local_recommendation_agent`의 `backstory`에 내용을 보강해보겠습니다. 예를 들어, **"현지의 실제 데이터와 환율 정보를 참고하여, 여행 예산을 현실적으로 산정해준다."**는 문장을 추가해보겠습니다. 수정된 에이전트 코드는 다음과 같습니다:

```python
local_recommendation_agent = Agent(
    role="현지 전문가",
    goal="여행 목적지에서 현지인이 선호하는 장소와 특별한 경험을 추천하여 여행을 풍성하게 합니다.",
    backstory="당신은 현지 문화와 지역 정보를 잘 이해하며, 현지 맛집, "
              "숨은 명소 등을 추천하는 전문가입니다. "
              "여행자가 현지에서 더욱 특별하고 기억에 남는 경험을 할 수 있도록 도와줍니다. "
              "또한 현지의 실제 데이터와 환율 정보를 참고하여 현실적인 예산 계획을 제시합니다.",
    tools=[
        NearbyPlacesTool(),
        ExchangeRateTool()
    ],
    verbose=True
)
```

위에서 굵게 표시된 부분이 새로 추가된 문장입니다. 이제 local_recommendation_agent는 **현실 데이터와 환율 정보 활용** 및 **예산 계획**에 대한 언급이 포함된 배경지식을 갖게 되었습니다. 이로써 에이전트는 답변 생성 시 "내가 현지 데이터를 참고해 정확한 정보를 주고, 예산도 잘 계산해줘야지"라는 방향으로 생각하게 될 것입니다.

> **참고:** 에이전트의 `role`, `goal`, `backstory` 등은 내부적으로 LLM에게 주어지는 시스템 프롬프트/지시사항의 일부로 활용됩니다. 따라서 적절한 맥락을 심어주는 것은 답변의 질 향상에 직접적인 영향을 줍니다.  
> 또한, 프롬프트 개선은 에이전트 설정뿐만 아니라 Task의 `description`을 다듬는 방식으로도 할 수 있습니다. 예를 들어 2단계 태스크의 설명에 **"필요하면 가용한 도구를 사용하여 최신 정보를 확인하세요"** 같은 내용을 추가하는 방법도 생각해볼 수 있습니다. 여기서는 에이전트 자체의 설정을 조정했지만, 상황에 따라 태스크 설명을 수정하는 것도 효과적입니다.

프롬프트를 수정한 후에는 파일을 저장하고 다음 단계를 진행합니다. 이제 local_recommendation_agent는 이전보다 구체적이고 현실적인 추천을 제공할 준비가 되었습니다.

## 터미널에서 애플리케이션 실행하기

이제 코드를 실행하여 실제 결과를 확인해보겠습니다. 이전 세션들에서는 Streamlit 등을 사용해 웹 인터페이스로 결과를 보았다면, 이번에는 **터미널(명령 프롬프트)**에서 직접 파이썬 프로그램을 구동하겠습니다. 터미널에서 실행하면, 로그와 출력 결과를 직접 텍스트로 확인할 수 있어 디버깅이나 세부 확인에 유리합니다.

**1) 환경 설정 확인:** 실제 API를 호출하려면 필요한 **API 키**들이 설정되어 있어야 합니다. 프로젝트 루트에 `.env` 파일을 만들고 다음 항목들을 포함했는지 확인하세요 (이미 설정되어 있다면 넘어갑니다).

- Amadeus API (항공편/호텔 검색) 키: `AMADEUS_CLIENT_ID`, `AMADEUS_CLIENT_SECRET`  
- Google Maps API (인근 장소 검색) 키: `GOOGLE_API_KEY`  
- ExchangeRate-API (환율) 키: `EXCHANGE_RATE_API_KEY`  

`.env` 파일 예시:
```env
AMADEUS_CLIENT_ID=YOUR_AMADEUS_CLIENT_ID
AMADEUS_CLIENT_SECRET=YOUR_AMADEUS_CLIENT_SECRET
GOOGLE_API_KEY=YOUR_GOOGLE_PLACES_API_KEY
EXCHANGE_RATE_API_KEY=YOUR_EXCHANGE_RATE_API_KEY
```
각자 발급받은 키 값으로 대체해 주세요. (만약 실제 키가 없다면, 도구 사용 시 오류가 발생할 수 있습니다. 이 경우 **모의(mock) 응답**을 반환하도록 `tools.py` 일부를 수정하거나, 키 발급 후 진행하시기 바랍니다.)

**2) 터미널에서 실행:** 프로젝트 폴더에서 터미널을 열고 다음 명령을 입력합니다:

```bash
$ python main.py
```

`main.py`에서는 Crew를 구성하고, 앞서 정의한 태스크들을 실행한 뒤 결과를 출력하도록 되어 있습니다. 내부적으로 `TravelCoordinatorCrew().crew().kickoff(inputs=...)`가 호출되어 1단계부터 3단계까지 순차 실행됩니다. 

**3) 실행 로그 확인:** `verbose=True` 설정 덕분에 진행 과정에서 각 에이전트의 **프롬프트 내용, 도구 호출, 응답 생성 과정** 등이 터미널에 출력될 수 있습니다. 예를 들어:
- 1단계에서 travel_info_agent가 항공편 검색을 위해 `FlightSearchTool`을 호출하고 있는지,
- 2단계에서 local_recommendation_agent가 `NearbyPlacesTool`을 사용해 실제 맛집/명소 데이터를 가져오는지,
- 3단계에서 coordinator_agent가 이전 단계의 내용을 받아 최종 문서를 작성하는지 등의 로그를 볼 수 있습니다.

이러한 로그는 문제 해결에 많은 도움을 주니 주의 깊게 살펴보세요. 만약 어떤 단계에서 에러가 발생한다면 (예: API 키 오류, 네트워크 문제 등), 터미널에 해당 오류 메시지가 나타날 것입니다.

**4) 결과 확인:** 모든 태스크가 완료되면 `main.py`에서 최종 결과를 `print`하게 됩니다. 이 결과가 바로 **완성된 여행 일정표**입니다. 다음 섹션에서는 이 결과에서 어떤 내용을 확인해야 하는지 다루겠습니다.

> **Tip:** 터미널 크기가 작아 출력이 잘리지 않도록 창 크기를 넉넉히 하거나, 출력 내용을 파일로 리다이렉트하여 보는 것도 방법입니다 (예: `python main.py > output.txt`).

## 실제 API 호출로 현지 추천 정보 가져오기

이번 실습의 큰 특징 중 하나는 **CrewAI 에이전트가 외부 API를 호출하여 실제 데이터를 활용**한다는 점입니다. 앞서 설정에서 확인한 것처럼, 에이전트들은 필요한 정보를 얻기 위해 다양한 **도구(Tool)**를 사용할 수 있습니다. 여기서는 현지 맛집/명소 추천과 환율 변환에 사용되는 주요 도구들의 동작을 이해해보겠습니다.

- **NearbyPlacesTool (인근 장소 검색 도구)**:  
  이 도구는 구글 맵스의 Places API를 활용하여 특정 장소 주변의 흥미로운 장소들(주로 관광명소나 맛집)을 검색합니다. `NearbyPlacesTool`은 `place_name`과 `radius`를 입력으로 받아, 해당 지점 주변의 상위 추천 장소들을 최대 5개까지 반환하도록 구현되어 있습니다.  
  내부적으로 `NearbyPlacesTool`은 **Text Search API**를 이용해 입력된 장소명(`place_name`)에 해당하는 좌표를 찾은 뒤, **Nearby Search API**를 통해 그 좌표 주변을 검색합니다. `tools.py`의 일부를 살펴보면:
  ```python
  # 장소명으로 좌표 얻기 (예: "오사카 맛집" 또는 "오사카 성")
  response = requests.get("https://maps.googleapis.com/maps/api/place/textsearch/json", params={ ... })
  # ... 중략 ...
  location = response["results"][0]["geometry"]["location"]  # 검색 결과 중 첫 번째 장소의 좌표
  
  # 좌표 주변의 관광명소 검색
  requests.get("https://maps.googleapis.com/maps/api/place/nearbysearch/json", params={
      "location": f"{lat},{lng}",
      "radius": radius,
      "type": "tourist_attraction",  # 관광명소 타입 (맛집도 일부 포함될 수 있음)
      "language": "ko",
      "key": GOOGLE_API_KEY
  })
  # ... 중략 ...
  return response["results"][:5]  # 최대 5개 장소 정보 반환
  ```
  이를 통해 예를 들어 `place_name="오사카"`로 검색하면 오사카 지역의 대표 관광지 리스트를 얻어올 수 있습니다. (참고: `type="tourist_attraction"`으로 설정되어 있어 **관광지 위주의 결과**를 가져오지만, 인기 맛집도 관광명소로 간주되는 경우 검색될 수 있습니다. 필요에 따라 이 파라미터를 `"restaurant"` 등으로 변경해 특정 유형의 장소를 얻는 것도 가능합니다.)

  또한 `NearbyPlacesTool.get_place_details()` 메서드는 각 장소별 세부 정보를 추가로 가져옵니다. 이름, 주소, 전화번호, 영업시간, 평점, 리뷰 등 유용한 정보들을 얻어와 결과 딕셔너리에 담습니다. 에이전트는 이러한 세부 정보를 활용해 추천 내용을 풍부하게 꾸밀 수 있습니다.

- **ExchangeRateTool (환율 도구)**:  
  이 도구는 **ExchangeRate-API**를 사용해서 통화 환산을 수행합니다. `from_currency`, `to_currency`, `amount`를 입력받아 실시간 환율에 따라 변환된 금액을 돌려줍니다.  
  예를 들어, 엔화를 원화로 변환해야 하는 경우 `from_currency="JPY"`, `to_currency="KRW"`, `amount=금액`으로 호출하면, 환전된 금액과 적용 환율 정보를 얻습니다. 코드를 보면 단순히 API 호출 결과 중 변환 금액을 추출하여 반환하고 있습니다.  
  ```python
  response = requests.get(f"https://v6.exchangerate-api.com/v6/{API_KEY}/pair/JPY/KRW/{amount}")
  data = response.json()
  converted_amount = data['conversion_result']
  ```
  이 값을 통해 에이전트는 예산을 원화 기준으로 계산해주게 됩니다. 예산 제한이 "80만 원"으로 주어졌다면, 엔화로 된 항목들도 환율을 적용한 뒤 원화 합산을 할 수 있겠죠.

이러한 도구 호출은 CrewAI 프레임워크 내에서 **에이전트의 결정에 따라 자동으로 실행**됩니다. 예를 들어 local_recommendation_agent는 2단계 설명을 읽고 "맛집과 명소 정보를 추가해야겠군, 도구를 써보자"라고 판단하면 `NearbyPlacesTool`을 호출할 것입니다. 호출 방법은 보이지 않지만, 프레임워크가 Agent에게 부여한 도구 리스트를 보고 마치 함수를 호출하듯 사용할 수 있게 합니다. (이 과정은 일종의 **행동 계획(Action)**으로, 에이전트가 내부적으로 문자열을 생성하면 프레임워크가 해당 도구 함수를 실행해 결과를 다시 에이전트에게 전달하는 방식입니다.)

**실제 API를 호출함으로써 얻는 이점:** 에이전트가 만들어내는 여행 일정이 훨씬 **현실적이고 신뢰도 높은 정보**를 담게 됩니다. 예를 들어, 현지 맛집의 이름이나 관광지의 상세정보, 실제 영업시간이나 리뷰 등은 AI 모델이 혼자 상상으로 생성하기 어렵지만, API로 얻은 데이터를 활용하면 정확한 내용을 반영할 수 있습니다. 또한 환율 변환을 통해 예산 계산이 정확해져서, 사용자의 예산 한도를 지키면서도 세부 내역이 타당한 플랜을 제시할 수 있습니다.

이제, 프롬프트를 개선하고 실시간 데이터 도구까지 갖춘 에이전트들이 협력하여 결과를 만들어낼 준비가 되었습니다. 다음으로, 예시 입력을 통해 프로그램을 실행한 결과를 검증해보겠습니다.

## 실습 결과 테스트 및 확인

이제까지 설정한 내용이 잘 작동하는지 **예시 시나리오**로 테스트해보겠습니다. `main.py`에 이미 입력된 예시를 그대로 사용할 수 있습니다. 입력은 한글로 작성된 여행 요청으로, **"인천 출발 -> 오사카 여행", "2025년 4월 25일부터 27일까지", "예산 80만 원", "혼자 여행, 가성비 좋은 곳 위주"** 등의 요구사항을 담고 있습니다. 구체적으로는 다음과 같습니다:

> **예시 입력:**  
> *"2025년 4월 25일부터 27일까지 인천을 출발해서 오사카로 여행을 다녀오려고 합니다. 항공편, 숙소, 현지 맛집, 가볼만한 곳까지 포함해서 여행 일정을 상세히 만들어주세요. 예산은 총 80만 원 이내로 잡고 있어요. 혼자 가는 여행이라 너무 비싸지 않으면서 가성비 좋은 곳들로 부탁드려요."*

프로그램을 실행하면 위 요청에 따른 최종 여행 일정 계획서가 출력됩니다. **올바르게 구현되었다면 다음과 같은 요소들이 포함되어야 합니다:**

- **항공편 정보**: 인천 ↔ 오사카 왕복 항공편의 세부 사항 (항공사, 출발/도착 시간 혹은 대략적인 정보, 예상 비용 등).
- **숙소 정보**: 오사카에서 숙박할 호텔 또는 게스트하우스 등의 정보 (이름, 위치, 숙박비 등).
- **일자별 일정**: 2025년 4월 25일 (1일차), 26일 (2일차), 27일 (3일차) 각각에 대해 아침/점심/저녁/간식 계획과 방문할 장소가 나열됩니다. 예를 들어:  
  - *1일차:* 오전 인천 출발 -> 오사카 도착, 호텔 체크인; **점심:** 오사카 현지 맛집 **X**에서 **음식Y** 맛보기 (¥가격, ~₩환산가격); 오후 **관광지 A** 구경 (입장료 ¥?, ~₩?); **저녁:** **맛집 B**에서 식사 (...); 등등.
  - *2일차:* 오사카 시내 관광 ... (아침 식사 장소, 관광, 점심, 관광, 저녁 등 추천)...
  - *3일차:* 귀국 일정 (오전 체크아웃, ... 오후 오사카 출발 -> 인천 도착)과 간식이나 남은 시간에 할 것 등.
- **현지 맛집 추천**: 각 식사 시간마다 가능한 **현지 음식점의 이름**과 **추천 메뉴**, **대략적인 가격**이 언급되어야 합니다. (에이전트가 NearbyPlacesTool로 찾은 식당이나 카페의 이름을 활용했을 가능성이 큽니다.)
- **가볼 만한 곳 추천**: 매일 일정 중에 방문하기 좋은 **관광지나 체험 장소**가 포함되어야 합니다. 역시 **장소 이름**과 **소요 비용(입장료 등)**이 표시되면 좋습니다.
- **상세 예산표**: 모든 비용 요소를 합산한 **예산 표**가 제시되어야 합니다. 항목별 (항공, 숙소, 식사, 교통, 입장료 등) 비용이 나열되고, 총합이 **80만 원 이내**인지 확인해야 합니다. 환율을 적용했다면 엔화로 책정된 비용들이 원화로 환산되어 있을 것입니다. 예를 들어, "항공권 50만원, 숙소 20만원, 식사 및 관광 10만원, 총합 80만원"과 같이 나올 수 있습니다.
- **한국어로 작성**: 모든 내용이 **한국어**로 자연스럽게 기술되어 있어야 합니다 (필요하면 영어/일본어 이름 옆에 한글 설명이 붙을 수도 있습니다).

결과물은 꽤 긴 글이 될 것이므로, 중요한 부분을 중심으로 살펴봅니다. 특히 **예산 합계가 80만 원을 넘지 않는지** 꼭 검토하세요. 만약 예산을 초과했다면, `local_recommendation_agent`의 프롬프트나 로직을 다시 한번 점검해야 합니다 (에이전트가 예산 제한을 잊지 않도록 프롬프트에 명시하거나, 예산 계산 방식을 수정하는 등 피드백 반영이 필요할 수 있습니다).

또한 추천된 맛집/명소가 실제로 그 지역과 관련이 있어 보이는지도 확인하세요. (예: 오사카 여행인데 뜬금없이 다른 지역 식당이 나오지 않았는지 등) 만약 전혀 관계없는 추천이 나왔다면, 프롬프트를 더 조정하거나 `NearbyPlacesTool`의 검색 쿼리를 바꾸는 등의 개선이 필요할 것입니다. 정상적으로 작동했다면 오사카의 대표적인 먹거리나 관광지가 언급되었을 것입니다.

**테스트를 위한 추가 아이디어:** 오사카 예시 외에 다른 입력으로도 한 번 실행해보세요. 예를 들어 "부산 출발 도쿄 여행, 5일간, 예산 100만원" 등의 시나리오로 입력을 바꿔서 프로그램을 돌려볼 수 있습니다. 새로운 지역에 대해서도 에이전트들이 제대로 대응하는지, 혹은 어디를 더 개선해야 할지 파악할 수 있는 좋은 연습이 됩니다.

## 정리 및 주요 개념

이번 실습을 통해 우리는 CrewAI 기반 여행 플래너의 현지 추천 기능을 확장하면서 여러 가지 중요한 개념을 학습했습니다:

- **다중 에이전트 협업 흐름**: CrewAI의 **Crew**가 어떻게 여러 **Task**를 **순차적으로 실행**하며, 각 Task 결과를 다음 Task의 **context**로 넘기는지 이해했습니다. 이를 통해 **에이전트 간 협업**으로 복잡한 문제(여행 일정 계획)를 단계적으로 해결하는 구조를 파악했습니다.
- **프롬프트 엔지니어링(Prompt Engineering)**: 에이전트의 역할, 목표, 배경을 세심하게 조정함으로써 답변의 질을 높일 수 있다는 것을 배웠습니다. 특히 `local_recommendation_agent`의 프롬프트를 개선하여 **도구 활용**과 **예산 인식** 같은 중요 요소를 강조함으로써 결과물을 더 현실적으로 만들었습니다.
- **터미널 기반 실행**: Streamlit 등의 UI 없이 **직접 파이썬 스크립트를 실행**하여 백엔드 로직을 테스트하는 방법을 익혔습니다. 터미널 출력으로 **디버깅 정보(verbose 로그)**를 확인하고, 프로그램의 최종 결과를 검증하는 과정을 통해 개발 단계에서의 효율적인 테스트 방법을 경험했습니다.
- **외부 API 통합**: CrewAI의 **Tools**를 이용해 외부 API (예: Amadeus, Google Places, ExchangeRate API)를 호출하고 그 결과를 활용하는 방법을 살펴보았습니다. 이를 통해 AI 모델의 한계를 보완하고 **신뢰할 수 있는 최신 정보**를 응답에 반영하는 중요성을 확인했습니다. 실제 데이터를 통합함으로써 사용자의 요구사항에 부합하는 더 정확한 결과를 생성할 수 있었습니다.
- **여행 플래너 앱의 실용성 향상**: 현지 맛집과 가볼만한 곳 추천, 세부 예산 계산까지 포함함으로써 여행 계획서의 **완성도**가 크게 높아졌습니다. 사용자는 AI가 제안한 일정이 단순한 아이디어 나열이 아니라, **구체적인 장소 이름과 비용 정보**까지 갖춘 유용한 계획임을 느낄 수 있을 것입니다.

이상으로 실습을 마칩니다. 😀 이번 단계까지 완료했다면, CrewAI 기반 여행 플래너는 기본적인 요구사항부터 현지 추천과 예산관리까지 아우르는 상당히 풍부한 기능을 갖추게 되었을 것입니다. 남은 세션에서도 이 토대를 바탕으로 더 흥미로운 기능들을 추가하거나 개선해 나갈 예정이니, 이번에 익힌 개념들을 잘 복습해두세요. 수고하셨습니다!


